
[alias]
# Basic shortcuts ----------------------------------------------------------------------------------
    
    rb = rebase
    rbo = rebase origin/master
    fp = push --force-with-lease
    co = switch
    sw = switch
    cm = commit
    cmm = commit -m
    oops = commit --amend --no-edit
    st = status
    fet = fetch -p

# Logging -----------------------------------------------------------------------------------------
    ls = log --pretty=format:'%C(bold yellow)%h%C(bold red)%d %Creset%s%C(bold blue) [%cn]' --decorate
    ll = log --pretty=format:'%C(bold yellow)%h%C(bold red)%d %Creset%s%C(bold blue) [%cn]' --decorate --numstat
    sl = log --graph --pretty=format:'%C(auto)%h%Creset%C(auto)%d%Creset %s %C(magenta bold)(%cr)%Creset %C(cyan)<%aN>%Creset' --all --simplify-by-decoration
    lb = "!git for-each-ref --sort='-authordate' --format='%(authordate)%09%(objectname:short)%09%(refname)' refs/heads | sed -e 's-refs/heads/--'"
    lg = log --graph --pretty=format:'%C(bold red)%h%Creset -%C(bold yellow)%d%Creset %s %C(bold green)(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --date=relative --all
    lf = log --format=format:'%C(bold cyan)%ar %C(reset) %C(green)%f' --name-status
    last = "!f() { git log -${1:-1} --stat ; } ; f"

# branches
    branch-name = "git rev-parse --abbrev-ref HEAD"

    # Clean up all local branches that do not have a remote reference.
    cleanup = "!f() { git check-remote -pq && git branch -vv | awk '/: gone]/{print $1}' | xargs git branch -D ; } ; f"

    # Push the current branch to the remote "origin", and set it to track the upstream branch
    publish = "!git push -u origin $(git branch-name)"

    # Delete the remote version of the current branch
    unpublish = "!git push origin :$(git branch-name)"

    # Start a new local repository and perform initial commit
    this = !git init && git add . && git commit -m \"Initial commit.\"

    # Create a new branch from base-remote master and publish it to origin
    create = "!f() { git check-remote -nq 2>/dev/null ; git checkout -b $1 $(git base-remote)/$(git default) && git push -u origin $(git branch-name); } ; f"

    # Delete all local branches and will leave the branch on master
    delete-local-branches="!git checkout master ; git branch --list | grep -v \\* | xargs git branch -D"

# Rebasing ----------------------------------------------------------------------------------------
    # like selfbase but will interactive rebase the number that you pass in. Ex
    # 'git nbase 3' will interactive rebase the last 3 commit in the branch.
    nbase = "!f() { git rebase -i HEAD~${1:-2} ; } ; f"

    # interactive rebase the current branch from the start of the branch
    selfbase = "! git nbase $(git branch-count)"

    # Rebasing on origin/(master/main)
    rbm = "!git fetch -nq 2>/dev/null ; git rebase ${1:-$(git base-remote)/$(git default)} ;"

    rba = rebase --abort
    rbc = rebase --continue
    rbs = rebase --skip

# Misc
    # Returns the default branch for a remote. Normally this is `master` or `main`
    default = "!f() { git symbolic-ref refs/remotes/${1:-origin}/HEAD | sed \"s@^refs/remotes/${1:-origin}/@@\" ; } ; f"

    # Gets the current number of commits on the current branch since the branch was made
    branch-count = "!f() { git rev-list --count HEAD ^${1:-origin/$(git default)}; }; f"

    # Returns the base remote for a repository. For a normal repository this will return origin.
    # When a repository is a fork I use the remote name `upstream` as the base remote name.
    # If the repository is a fork it will return the remote `upstream` as that is the base of
    # the project, as this one is a fork.
    base-remote = "!f() { \
        [[ -n $(git remote | grep -E '^upstream$') ]] && echo upstream || echo origin ; \
    } ; f"

    ec = "!nvim-qt ~/.gitconfig"
    ecl = "!nvim-qt ~/.local/.gitconfig"

[include]
    path = ~/.local/.gitconfig
[pull]
	rebase = true
[init]
	defaultBranch = main
[merge]
	tool = vimdiff
[mergetool]
	path = nvim
